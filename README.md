# Java Readme

## Taxi-4

本次作业花了很多时间，但是由于时间紧任务重作业指导书不明确等原因，难免会有考虑不周之处和没有来得及进行充分测试留下的bug，请多包涵。另外，如果你在测试中发现一些会导致无效作业的问题的话：.._:(?_`」 ∠):_ ...跪下求饶

## 输入

### 控制台输入的所有指令格式

在此处仅给出大致的列表和格式，详细信息请向下阅读

```java
// 程序开始时输入是否LoadFile
Y/N
// LoadFile
Load fileName	// Load loadFile.txt
// 乘客请求
[CR,(srcx,srcy),(dstx,dsty)]	// [CR,(68,68),(75,0)]
// 关闭道路
[CLOSE,(SRCX,SRCY),(DSTX,DSTY)]	// [CLOSE,(0,0),(0,1)]
// 打开道路
[OPEN,(SRCX,SRCY),(DSTX,DSTY)]	// [OPEN,(0,0),(0,1)]
// 查询可迭代出租车的信息
[CHECK,index]	// [CHECK,0]
```

### 地图输入

地图文件的路径和文件名在接口`DEFINE`中设置，默认为项目路径下的map.txt中

直接使用了`GUI`包中的地图读入和`BFS`算法等内容，因此请不要对`GUI`包中的相关部分进行修改

将`GUI`包中所需的类提出成单独的`.java`文件，但原有代码的算法没有修改，仅增加了所需的方法

以下四个文件是从gui.java中提取出的，根据issue要求，GUI包中的方法不需要写JSF

```
GUI.java
GUIGv.java
GUIInfo.java
TaxiGUI.java
```

请严格按照作业指导书指定的格式（即示例地图的格式）进行输入

### 红绿灯输入

地图文件的路径和文件名在接口`DEFINE`中设置，默认为项目路径下的light.txt中

直接使用了`GUI`包中的红绿灯设置等内容，因此请不要对`GUI`包中的相关部分进行修改

请严格按照作业指导书指定的格式进行输入

根据不同助教对于不同班级的冲突要求，以及最后和助教确认可以readme中规定，代码中所有红绿灯的方向全部随机，即所有红绿灯绿的方向不一致

红绿灯切换的时间间隔为`Random().nextInt(500)+500`

根据issue的要求，红绿灯对于车辆掉头的控制可以自定义，规定如下：掉头时也需要等待红绿灯，例如从(1,1)向东行驶到(1,2)，如果要行驶回(1,1)，需要等待东西方向的绿灯

相对于车辆当前方向向右行驶不需要等待绿灯，例如先向北行驶再向东行驶，第二步移动不需要等待绿灯

出租车接收到的红绿灯信息为其到达目标点的一瞬间收到的，如果在出租车在两条边移动的过程中（即sleep500的过程中），红绿灯改变使其前进方向为红灯或通过关闭了出租车正处在的道路上，这样的情况将被忽略，认为出租车已经在该条道路上行驶。因此，只要车辆到达该点时目标方向上是绿灯，都可以直接前进，所以可能会出现车辆到达该点时是绿灯，但是车辆位置改变（即sleep500）之后，可能已经变为红灯，但是由于车辆已经在该道路上行驶，不进行处理。

根据issue的要求，在非路口设定红绿灯的行为如下：提示，然后忽略该红绿灯，不予设置。

### 乘客请求输入

乘客请求格式：

```java
[CR,(srcx,srcy),(dstx,dsty)] 
```

输入的空行将被舍弃，输入`END` 时结束程序，即使有没有执行完毕的请求

输入时如果判断输入了相同的请求（即两条相同请求的发出时间除以100ms后的结果相等），后输入的将被舍弃

输入的任何一个坐标的x或y不满足0~79的限制的话，该指令将被舍弃

如果输入的请求发出点和目的点相同，也将被舍弃

每5S进行一次搜索，删除掉已经被处理的、不会再导致同质请求的请求，如果在搜索删除的过程中，传入了新的请求，将出现`warning`提示，可以忽略

如果输入的请求过多，可能会导致JVM的内存泄漏而crash，请自行调高JVM的内存上限

### 开关道路

指令格式

```
[CLOSE,(SRCX,SRCY),(DSTX,DSTY)]
[OPEN,(SRCX,SRCY),(DSTX,DSTY)]
```

输入的两个点必须是相邻点

对已关闭/不通的道路进行CLOSE和对已开通的道路进行OPEN不会报错，不改变其原有的连通性，但是对地图文件中原本就不连通的道路进行打开操作不被支持。

### Loadfile

请严格按照作业指导书中的规定格式进行输入，请忽略因格式错误导致的问题

对loadfile输入的请求的规定：

与正常在控制台的输入格式保持一致，即两个点之间需要有逗号

```
[CR,(SRCX,SRCY),(DSTX,DSTY)]
```

另外，出租车状态设定时，只能够设定为等待派单的随机运动状态和停止1s的状态，接送乘客的状态不被支持，因为无法指定接送乘客的目的地等信息，因此如果尝试输入设定为这两个状态，将被设定为默认的随机运动状态

## 输出

### 流量

根据issue的要求，流量算法更新如下：

不再每500MS一刷新，而是即时刷新，流量时间窗口为T-500到T之间

**特别注意：**此处更改直接在GUI的流量算法中中进行更改，因此请不要对GUI加以修改，GUI的表现和实际流量不冲突

### GUI

GUI的结果仅供参考，而且在自行测试的过程中发现GUI可能会自行crash的问题，请忽略GUI自身的一切错误

GUI中的流量算法已做更新

出租车的四种状态如下：

```java
int STOP = 0; // 停止状态，包括出租车停车接送乘客的1s
int SERVING = 1; // 正在送乘客到目的地
int WAITING = 2; // 等待派单，即随机运动状态
int READY = 3; // 去接乘客的过程
```

可能会与你所理解的GUI定义的状态不符，可以自行修改或……对付着看

### 控制台输出

控制台输出的结果仅供参考，同时由于如果有多个请求同时执行，那么由于多线程执行的随机性，输出结果可能会难以阅读

### 文件输出：乘客请求的处理过程

给定一个`FileWriter`类，该类用于处理所有的文件输出内容

乘客请求的处理过程被输出到当前项目路径下的`detail.txt`文件中

另外，请注意，对于一条乘客请求，输出到文件中的所有接单的出租车信息中的位置是**派单时刻的出租车位置**，为了便于判断接单的出租车是否是信用度最小的出租车中最近的一辆，而**不是出租车抢单时刻的位置**。

### 文件输出： 测试接口

提供了两个测试接口，调用时将所需要的信息输出到当前项目路径下的`summary.txt`文件中

```java
    public synchronized void taxiCheck(int taxiNum)
```

用于查询指定的出租车的状态信息，直接输出到文件，无返回值

```java
    public synchronized LinkedList<Integer> statusCheck(int status)
```

用于查询制定状态的出租车并输出到文件，同时返回存储了这些出租车序号的链表

## VIP出租车和LSP

### VIP出租车的规定

#### 迭代器

通过`public ListIterator<HistoryRecord> iterator()`方法，得到一个处理过的所有请求的迭代器，迭代的对象是在可追踪出租车中的`LinkedList`中存储的每一个历史请求。

在`HistoryRecord`类中存储了可追踪出租车处理过的每一次请求，存储了请求编号、**请求开始处理的时间**（而不是请求被读入的时间）、请求的发出点、目的点、接到请求的时间、位置信息、处理请求的过程中经过的每一个地图点等信息。

因此，对于一个可追踪出租车的编号（大于等于0小于30）`index`，对其所有的请求处理进行迭代的方法为

```java
ListIterator<HistoryRecord> iterator = Main.taxiQueue.getIterator(index);
while(iterator.hasNext())
{
    iterator.next().printHistory();
}
```

#### 获取处理过的所有请求的信息

上述方法在控制台输入线程中实现，输入以下格式

```
[CHECK,(index)]
[CHECK,0]
```

`(index)`是一个可追踪出租车的编号（0 <= index < 30）

将在控制台输出该出租车处理过的所有请求的编号、派单时间、派单地点、运动路径。

PS：此处存储的派单信息可能与输出到文件的信息有1ms左右的差别，原因是先进行了运动的存储和执行，然后再进行输出，这之间需要时间。

### LSP原则

与普通出租车相比，除了增加迭代和记录以外，没有增加新的内容，对于所需的新的判断两个点连通与否的算法（对于普通出租车，地图文件中不连通的路径和后关闭的路径一致处理，对于VIP出租车，人为关闭而地图文件中相邻的点被忽略，依旧视为连通），对于接送单时的路径选择算法（由连通点的判断方法不同而不同）的这两个算法，都在外部的算法层面进行了修改。

对于原有的普通出租车，传入的是默认值，即进行原有的操作；而对于VIP出租车，使用override进行覆盖，传入的是VIP出租车类型标记，即进行特殊的判断联通和所搜最短路径算法。

因此，如果将原有的`Taxi`类型使用`VIPTaxi`替换，相当于将该出租车定义为可追踪的特殊出租车，行为模式与可追踪出租车一致，黑盒暴露给外部的接口定义、用法保持一致，因此如果只更改了出租车的类型而没有对出租车的调用方法等进行修改，也不会报错，将正常执行。这也是本项目中实际所实现了的内容。

对于`VIPTaxi`独有的方法和属性，由于使用到原`Taxi`类的地方也不会使用到这些新增内容，因此，原有的方法没有冲突。代码中保证了LSP原则的实现。

## 其他规定

1. 如果测试过程中，发现控制台中出现了红色的报错提示，请确认是否是e.printStackTrace()的输出

2. 只要出租车第一次行驶到某请求的有效范围内，马上将其信用度+1

3. 在出租车将乘客送至目的地并等候1s后，信用度+3

4. 如果多个请求被同一辆出租车接单而且只有该出租车接单，将仅有一个请求会被派给该车，其余请求提示没有有效的车并被舍弃

5. 如果某车在被派单的时刻正处在两个点之间（即sleep 500ms时）或者在等待红绿灯的期间，将在醒来后再执行请求，但是执行请求前不会再随机移动一个点。因此，可能出现以下情况：

   派单时刻，出租车处在点`(x,y)`，正在前往`(x,y+1)`的路上，因此，记录到的派单时刻出租车所处的位置为`(x,y)`。出租车运动完毕，到达`(x,y+1)`，在该点处理前往请求发出点接乘客的过程，因此，在文件输出和VIP出租车的记录中，第一个移动路径点可能为`(x,y+2)`，即与记录的派单点中间还有一步移动。

6. **如果某车在被派单的时刻正处在两个点之间（即sleep 500ms时），认为该车已经处在两个点之间的道路上，如果此时关闭该条道路，该辆出租车也将不会改变道路而是继续沿该边前进**

7. 在某辆车被派单后，将立即转入接客状态，并在结束服务、将乘客送达目的地之前不再每20S停止1S，此外，在送达乘客、等候1S之后，将从零开始计算20S

8. 由于多线程执行的随机性和每条指令的执行都需要时间，边缘情况的执行情况不可预料，通过readme也无法准确规定，所以对于测试者来说请不要在例如接单检测窗口期开始和结束时的节点附近卡 bug。

9. `readme`未全面覆盖的问题，如果代码中有所体现，请以代码实际执行情况为准；如果没有考虑周全，敬请谅解

## 上次作业的BUG

无




程序中存在的问题请多包涵，不要互相伤害，虽然已经进行过一些测试，但是由于时间等关系，没有进行完整的测试，如果可能出现无效问题的话……再次跪求

/*非常感谢你耐心读到这里！谢谢你！大家共同进步，祝OO顺利(⊙ω⊙)！*/