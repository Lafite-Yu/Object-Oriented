# Java Readme

## Taxi-3

本次作业花了很多时间，但是由于时间紧任务重作业指导书不明确等原因，难免会有考虑不周之处和没有来得及进行充分测试留下的bug，请多包涵。另外，如果你在测试中发现一些会导致无效作业的问题的话：.._:(?_`」 ∠):_ ...跪下求饶

## 输入

### 地图输入

地图文件的路径和文件名在接口`DEFINE`中设置，默认为项目路径下的map.txt中

直接使用了`GUI`包中的地图读入和`BFS`算法等内容，因此请不要对`GUI`包中的相关部分进行修改

将`GUI`包中所需的类提出成单独的`.java`文件，但原有代码的算法没有修改，仅增加了所需的方法

以下四个文件是从gui.java中提取出的，根据issue要求，GUI包中的方法不需要写JSF

```
GUI.java
GUIGv.java
GUIInfo.java
TaxiGUI.java
```

请严格按照作业指导书指定的格式（即示例地图的格式）进行输入

### 红绿灯输入

地图文件的路径和文件名在接口`DEFINE`中设置，默认为项目路径下的light.txt中

直接使用了`GUI`包中的红绿灯设置等内容，因此请不要对`GUI`包中的相关部分进行修改

请严格按照作业指导书指定的格式进行输入

根据不同助教对于不同班级的冲突要求，以及最后和助教确认可以readme中规定，代码中所有红绿灯的方向全部随机，即所有红绿灯绿的方向不一致

红绿灯切换的时间间隔为`Random().nextInt(500)+500`

根据issue的要求，红绿灯对于车辆掉头的控制可以自定义，规定如下：掉头时也需要等待红绿灯，例如从(1,1)向东行驶到(1,2)，如果要行驶回(1,1)，需要等待东西方向的绿灯

相对于车辆当前方向向右行驶不需要等待绿灯，例如先向北行驶再向东行驶，第二步移动不需要等待绿灯

出租车接收到的红绿灯信息为其到达目标点的一瞬间收到的，如果在出租车在两条边移动的过程中（即sleep500的过程中），红绿灯改变使其前进方向为红灯或通过关闭了出租车正处在的道路上，这样的情况将被忽略，认为出租车已经在该条道路上行驶。因此，只要车辆到达该点时目标方向上是绿灯，都可以直接前进，所以可能会出现车辆到达该点时是绿灯，但是车辆位置改变（即sleep500）之后，可能已经变为红灯，但是由于车辆已经在该道路上行驶，不进行处理。

根据issue的要求，在非路口设定红绿灯的行为如下：提示，然后忽略该红绿灯，不予设置。

### 乘客请求输入

乘客请求格式：[CR,(srcx,srcy),(dstx,dsty)] 

输入的空行将被舍弃，输入`END` 时结束程序，即使有没有执行完毕的请求

输入时如果判断输入了相同的请求（即两条相同请求的发出时间除以100ms后的结果相等），后输入的将被舍弃

输入的任何一个坐标的x或y不满足0~79的限制的话，该指令将被舍弃

如果输入的请求发出点和目的点相同，也将被舍弃

每5S进行一次搜索，删除掉已经被处理的、不会再导致同质请求的请求，如果在搜索删除的过程中，传入了新的请求，将出现`warning`提示，可以忽略

如果输入的请求过多，可能会导致JVM的内存泄漏而crash，请自行调高JVM的内存上限

### 开关道路

指令格式

```
[CLOSE,(SRCX,SRCY),(DSTX,DSTY)]
[OPEN,(SRCX,SRCY),(DSTX,DSTY)]
```

输入的两个点必须是相邻点

对已关闭/不通的道路进行CLOSE和对已开通的道路进行OPEN不会报错，不改变其原有的连通性

### Loadfile

请严格按照作业指导书中的规定格式进行输入，请忽略因格式错误导致的问题

对loadfile输入的请求的规定：

与正常在控制台的输入格式保持一致，即两个点之间需要有逗号

```
[CR,(SRCX,SRCY),(DSTX,DSTY)]
```

另外，出租车状态设定时，只能够设定为等待派单的随机运动状态和停止1s的状态，接送乘客的状态不被支持，因为无法指定接送乘客的目的地等信息，因此如果尝试输入设定为这两个状态，将被设定为默认的随机运动状态

## 输出

### 流量

根据issue的要求，流量算法更新如下：

不再每500MS一刷新，而是即时刷新，流量时间窗口为T-500到T之间

**特别注意：**此处更改直接在GUI的流量算法中中进行更改，因此请不要对GUI加以修改，GUI的表现和实际流量不冲突

### GUI

GUI的结果仅供参考，而且在自行测试的过程中发现GUI可能会自行crash的问题，请忽略GUI自身的一切错误

GUI中的流量算法已做更新

出租车的四种状态如下：

```java
int STOP = 0; // 停止状态，包括出租车停车接送乘客的1s
int SERVING = 1; // 正在送乘客到目的地
int WAITING = 2; // 等待派单，即随机运动状态
int READY = 3; // 去接乘客的过程
```

可能会与你所理解的GUI定义的状态不符，可以自行修改或……对付着看

### 控制台输出

控制台输出的结果仅供参考，同时由于如果有多个请求同时执行，那么由于多线程执行的随机性，输出结果可能会难以阅读

### 文件输出：乘客请求的处理过程

给定一个`FileWriter`类，该类用于处理所有的文件输出内容

乘客请求的处理过程被输出到当前项目路径下的`detail.txt`文件中

另外，请注意，对于一条乘客请求，输出到文件中的所有接单的出租车信息中的位置是**派单时刻的出租车位置**，为了便于判断接单的出租车是否是信用度最小的出租车中最近的一辆，而**不是出租车抢单时刻的位置**。

### 文件输出： 测试接口

提供了两个测试接口，调用时将所需要的信息输出到当前项目路径下的`summary.txt`文件中

```java
    public synchronized void taxiCheck(int taxiNum)
```

用于查询指定的出租车的状态信息，直接输出到文件，无返回值

```java
    public synchronized LinkedList<Integer> statusCheck(int status)
```

用于查询制定状态的出租车并输出到文件，同时返回存储了这些出租车序号的链表

## 其他规定

1. 如果测试过程中，发现控制台中出现了红色的报错提示，请确认是否是e.printStackTrace()的输出
2. 只要出租车第一次行驶到某请求的有效范围内，马上将其信用度+1
3. 在出租车将乘客送至目的地并等候1s后，信用度+3
4. 如果多个请求被同一辆出租车接单而且只有该出租车接单，将仅有一个请求会被派给该车，其余请求提示没有有效的车并被舍弃
5. 如果某车在被派单的时刻正处在两个点之间（即sleep 500ms时），将在醒来后再执行请求，但是执行请求前不会再随机移动一个点
6. **如果某车在被派单的时刻正处在两个点之间（即sleep 500ms时），认为该车已经处在两个点之间的道路上，如果此时关闭该条道路，该辆出租车也将不会改变道路而是继续沿该边前进**
7. 在某辆车被派单后，将立即转入接客状态，并在结束服务、将乘客送达目的地之前不再每20S停止1S，此外，在送达乘客、等候1S之后，将从零开始计算20S
8. 由于多线程执行的随机性和每条指令的执行都需要时间，边缘情况的执行情况不可预料，通过readme也无法准确规定，所以对于测试者来说请不要在例如接单检测窗口期开始和结束时的节点附近卡 bug。
9. `readme`未全面覆盖的问题，如果代码中有所体现，请以代码实际执行情况为准；如果没有考虑周全，敬请谅解

## 上次作业的BUG

1. 在出租车随机移动的过程中没有考虑流量



程序中存在的问题请多包涵，不要互相伤害，虽然已经进行过一些测试，但是由于时间等关系，没有进行完整的测试，如果可能出现无效问题的话……再次跪求

/*非常感谢你耐心读到这里！谢谢你！大家共同进步，祝OO顺利(⊙ω⊙)！*/