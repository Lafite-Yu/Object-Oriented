# 类实现正确性推理

## 关于第14次作业代码部分的更新

1.  修复了第三次作业中被发现，第十三次作业中自己测试复现但是没有重构处理掉的bug
2.  补充了除了RequestQueue、Scheduler、Elevator以外其他类的JSF
3.  对代码结构进行了调整，对调度器算法大幅重构，大幅精简算法，分离方法功能较少代码规格以方便本次作业后续工作= =

## Main

### 1. 抽象对象有效实现论证 

```java
public class Main
{
    /** @OVERVIEW: 初始化其它类，调用请求读入和请求处理
     * @INHERIT: None
     * @INVARIANT: requestReader != null
     *              && requestsQueue != null
     *              && lights !=  null
     *              && scheduler != null
     */
```

Main类用于初始化其它类，并调用其他类的方法进行请求的读入和处理。

### 2. 对象有效性论证

**a) 针对构造方法，论证初始态对象的repOK为真。**

使用默认构造方法，显然成立

**b)逐个论证每个对象状态更改方法的执行都不会导致repOK的返回值为false。**

Main类中只有一个main方法和repOK，main中只有两个对其他方法的调用，不会改变对象的状态，因此没有对象状态更改方法

**c)该类的几个方法的执行皆不改变对象状态，因此这些方法执行前和执行后的repOK都为true。**

**d)综上，对该类任意对象的任意调用都不会改变其repOK为true的特性。因此该类任意对象始终保持对象有效性。**

### 3. 方法实现正确性论证

#### main()

```java
	/**
     * @EFFECTS: use other methods to read in and handle the requests.
     */
    public static void main(String[] args)	
    {
        requestReader.readin();
        scheduler.schedule();
    }
```

根据以上规格获得以下划分：

`<调用readin和schedule> with <nothing>`

-   [x] 该方法仅有两行相关代码，全部用于进行相关方法的调用，必然满足要求

#### repOK()

```java
	/**
     * @EFFECTS: \result == I_CLASS(\this)
     */
    public boolean repOK()
    {
        if (requestReader != null && requestsQueue != null && lights != null && scheduler != null)
            return true;
        return false;
    }
```

根据以上规格获得以下划分：

`<if this is legal, return true>with<nothing>`
`<if this is not legal, return false>with<nothing>`

-   [x] 检查对象有效性时被调用，调用时检查各属性满足要求，因此实现正确功能

------

## Request

### 1. 抽象对象有效实现论证

```java
public class Request
{
    /** @OVERVIEW: 记录请求信息
     * @INHERIT: None
     * @Abstract_Function: AF(r)=(index, type, floor, time, handled) where index==r.index, type==r.type, floor==r.floor,
     *                      time==r.time, handled==r.handled
     * @INVARIANT: index >= 0;
     *              && type == DEFINE.ER || type == DEFINE.FRUP || type == DEFINE.FRDOWN
     *              && 1 <= floor <= 10
     *              && time >= 0
     */
```

Request仅用于记录请求的序号、类型、发出时间、请求楼层和是否已经被处理的标记位，抽象函数中将它们映射到了对应的数据结构。 

### 2. 对象有效性论证

**a) 针对构造方法，论证初始态对象的repOK为真。**

```java
    /**@Requires: index >= 0;
     *              && type == DEFINE.ER || type == DEFINE.FRUP || type == DEFINE.FRDOWN
     *              && 1 <= floor <= 10
     *              && time >= 0
     *@Modifies: this
     * @Effects: this != null
     */
    public Request(int index, int type, int floor, long time)
    {
        this.type = type;
        this.floor = floor;
        this.time = time;
        this.index = index;
        this.handled = false;
    }
```

构造方法为各个属性赋了初始值，易知构造方法执行后repOK显然成立

**b)逐个论证每个对象状态更改方法的执行都不会导致repOK的返回值为false。**

没有状态更改方法，均为set/get/repOK

**c)该类的几个方法的执行皆不改变对象状态，因此这些方法执行前和执行后的repOK都为true。**

**d)综上，对该类任意对象的任意调用都不会改变其repOK为true的特性。因此该类任意对象始终保持对象有效性。**

### 3. 方法实现正确性论证

#### Request()

```java
    /**@Requires: index >= 0;
     *              && type == DEFINE.ER || type == DEFINE.FRUP || type == DEFINE.FRDOWN
     *              && 1 <= floor <= 10
     *              && time >= 0
     *@Modifies: this
     * @Effects: this != null
     */
    public Request(int index, int type, int floor, long time)
    {
        this.type = type;
        this.floor = floor;
        this.time = time;
        this.index = index;
        this.handled = false;
    }
```

根据以上规格获得以下划分：

`<initialize all the var> with <Requires>` 

-   [x] Request类的构造函数，将各个信息根据输入的内容进行初始化然后构造产生对象，满足要求

#### repOK()

```java
	/**
     * @EFFECTS: \result == I_CLASS(\this)
     */
    public boolean repOK()
    {
        if (index >= 0 && (type == DEFINE.ER || type == DEFINE.FRUP || type == DEFINE.FRDOWN) && floor >= 1 && floor <= 10 && time >= 0)
            return true;
        return false;
    }
```

根据以上规格获得以下划分：

`<if this is legal, return true>with<nothing>`
`<if this is not legal, return false>with<nothing>`

-   [x] 检查对象有效性时被调用，调用时检查各属性满足要求，因此实现正确功能

------

## LightInfo

### 1. 抽象对象有效实现论证

```java
class LightInfo
    {
        /** @OVERVIEW: 记录楼层和电梯内对应请求的一个灯的信息，包括是否亮灯、亮灯的指令序号、亮灯的指令时间
         * @Abstract_Function: AF(li)=(light, index, time) where light == li.light, index == li.index, time == li.time
         * @INVARIANT: index >= 0;
         *              && time >= 0
         */
```

LightInfo仅用于记录一条楼层或电梯内对应请求的灯的信息，包括是否亮灯、亮灯的指令序号、亮灯的指令时间，抽象函数中将它们映射到了对应的数据结构。 

### 2. 对象有效性论证

**a) 针对构造方法，论证初始态对象的repOK为真。**

使用默认构造方法，指定初始值，必然成立

**b)逐个论证每个对象状态更改方法的执行都不会导致repOK的返回值为false。**

没有状态更改方法，所有属性均为package-private，只有repOK方法

**c)该类的几个方法的执行皆不改变对象状态，因此这些方法执行前和执行后的repOK都为true。**

**d)综上，对该类任意对象的任意调用都不会改变其repOK为true的特性。因此该类任意对象始终保持对象有效性。**

### 3. 方法实现正确性论证

#### repOK()

```java
/**
* @EFFECTS: \result == I_CLASS(\this)
*/
public boolean repOK()
{
    if (index >= 0 && time >= 0)
        return true;
    return false;
}	
```

根据以上规格获得以下划分：

`<if this is legal, return true>with<nothing>`
`<if this is not legal, return false>with<nothing>`

-   [x] 检查对象有效性时被调用，调用时检查各属性满足要求，因此实现正确功能

------

## Lights

### 1. 抽象对象有效实现论证

```java
public class Lights implements DEFINE
{
    /** @OVERVIEW: 记录并处理楼层和电梯内请求对应的灯光
     * @Abstract_Function: AF(l)=(ERLight, FRUPLight, FRDOWNLight) where
     *                      ERLight == l.ERLight, FRUPLight == l.FRUPLight, FRDOWNLight == l.FRDOWNLight
     * @INVARIANT: ERLight != null && ( 0 <= i < ERLight.size ==> ERLight[i] instance of LightInfo)
     *              && FRUPLight != null && ( 0 <= i < FRUPLight.size ==> FRUPLight[i] instance of LightInfo)
     *              && FRDOWNLight != null && ( 0 <= i < FRDOWNLight.size ==> FRDOWNLight[i] instance of LightInfo)
     */
```

Lights仅用于记录并处理楼层和电梯内请求的灯光，抽象函数中将它们映射到了对应的数据结构。 

### 2. 对象有效性论证

**a) 针对构造方法，论证初始态对象的repOK为真。**

```java
/**@Modifies: this
     * @Effects: this != null
     *          && 0 <= i < ERLight.size ==> ERLight[i] == new LightInfo
     *          && 0 <= i < FRUPLight.size ==> FRUPLight[i] == new LightInfo
     *          && 0 <= i < FRDOWNLight.size ==> FRDOWNLight[i] == new LightInfo
     */
    public Lights()
    {
        for (int i = 0; i < 10; i++)
        {
            ERLight[i] = new LightInfo();
            FRUPLight[i] = new LightInfo();
            FRDOWNLight[i] = new LightInfo();
        }
    }
```

与在定义各成员属性时进行的初始化一起，构造了三种请求对应的三个存储灯的信息的队列，然后对队列中的每一项进行初始化保证其不为空，易知构造方法执行后repOK显然成立

**b)逐个论证每个对象状态更改方法的执行都不会导致repOK的返回值为false。**

除repOK外的所有方法均为根据输入的内容进行分支判断后再进行get/set的方法，因此都不会改变对象状态

**c)该类的几个方法的执行皆不改变对象状态，因此这些方法执行前和执行后的repOK都为true。**

**d)综上，对该类任意对象的任意调用都不会改变其repOK为true的特性。因此该类任意对象始终保持对象有效性。**

### 3. 方法实现正确性论证

#### Lights()

```java
		/**@Modifies: this
     * @Effects: this != null
     *          && 0 <= i < ERLight.size ==> ERLight[i] == new LightInfo
     *          && 0 <= i < FRUPLight.size ==> FRUPLight[i] == new LightInfo
     *          && 0 <= i < FRDOWNLight.size ==> FRDOWNLight[i] == new LightInfo
     */
    public Lights()
    {
        for (int i = 0; i < 10; i++)
        {
            ERLight[i] = new LightInfo();
            FRUPLight[i] = new LightInfo();
            FRDOWNLight[i] = new LightInfo();
        }
    }
```

根据以上规格获得以下划分：

`<initialize all the var> with <Requires>` 

-   [x] Lights类的构造函数，构造三个由于存储信息的队列并对队列中的每一项进行初始化

#### repOK()

```java
/**@EFFECTS: \result == I_CLASS(\this);
     */
    public boolean repOK()
    {
        if (ERLight == null || FRUPLight == null || FRDOWNLight == null)
            return false;
        for (int i = 0; i < 10; i++)
        {
            if ( !(ERLight[i] instanceof LightInfo) || !(FRUPLight[i] instanceof LightInfo) || !(FRDOWNLight[i] instanceof LightInfo))
                return false;
        }
        return true;
    }
```

根据以上规格获得以下划分：

`<if this is legal, return true>with<nothing>`
`<if this is not legal, return false>with<nothing>`

-   [x] 检查对象有效性时被调用，调用时检查各属性满足要求，因此实现正确功能

#### getLight()

```java
		/** @REQUIRES:  type == DEFINE.ER || type == DEFINE.FRUP || type == DEFINE.FRDOWN
     *              && 1 <= floor <= 10;
     * @MODIFIES: None;
     * @EFFECTS: type == DEFINE.ER ==> \result == ERLight[floor-1]
     *          type == DEFINE.FRUP ==> \result == FRUPLight[floor-1]
     *          type == DEFINE.FRDOWN ==> \result == FRDOWNLight[floor-1]
     */
    public LightInfo getLight(int type, int floor)
    {
        if (type == ER)
            return ERLight[floor-1];
        else if (type == FRUP)
            return FRUPLight[floor-1];
        else
            return FRDOWNLight[floor-1];
    }
```

根据以上规格获得以下划分：

`<return ERLight[floor-1]>with<type == ER, 1<= floor <= 10>`

`<return FRUPLight[floor-1]>with<type == FRUP, 1<= floor <= 10>`

`<return FRDOWNLight[floor-1]>with<type == FRDOWN, 1<= floor <= 10>`

-   [x] 代码完成的工作与规格划分相符

#### lightOn()

```java
    /** @REQUIRES:  request != null;
     * @MODIFIES: this.ERLight, this.FRDOWNLight, this.FRUPLight;
     * @EFFECTS: request.type == DEFINE.ER
     *              ==>如果ERLight[request.floor -1]没有亮起 ==>点亮ERLight[request.floor -1]并将对应请求的信息写入其中，\result == true;
     *              ==>如果ERLight[request.floor -1]已经亮起 ==> \result == false;
     *          request.type == DEFINE.FRUP
     *              ==>如果FRUPLight[request.floor -1]没有亮起 ==>点亮FRUPLight[request.floor -1]并将对应请求的信息写入其中，\result == true;
     *              ==>如果FRUPLight[request.floor -1]已经亮起 ==> \result == false;
     *          request.type == DEFINE.FRDOWN
     *              ==>如果FRDOWNLight[request.floor -1]没有亮起 ==>点亮FRDOWNLight[request.floor -1]并将对应请求的信息写入其中，\result == true;
     *              ==>如果FRDOWNLight[request.floor -1]已经亮起 ==> \result == false;
     */
    public boolean lightOn(Request request)
    {
        if (request.getType() == 0)
        {
            if (ERLight[request.getFloor() -1].light)
                return false;
            else{
                ERLight[request.getFloor() -1].light = true;
                ERLight[request.getFloor() -1].time = request.getTime();
                ERLight[request.getFloor() -1].index = request.getIndex();
            }
        }else if (request.getType() == 1)
        {
            if (FRUPLight[request.getFloor() -1].light)
                return false;
            else{
                FRUPLight[request.getFloor() -1].light = true;
                FRUPLight[request.getFloor() -1].time = request.getTime();
                FRUPLight[request.getFloor() -1].index = request.getIndex();
            }
        }else
        {
            if (FRDOWNLight[request.getFloor() -1].light)
                return false;
            else{
                FRDOWNLight[request.getFloor() -1].light = true;
                FRDOWNLight[request.getFloor() -1].time = request.getTime();
                FRDOWNLight[request.getFloor() -1].index = request.getIndex();
            }
        }
        return true;
    }
```

根据以上规格获得以下划分：

`<点亮ERLight中与请求楼层相对的灯，同时将请求信息写入其中，return true>with<request.type == ER，对应的ERLight[request.floor-1]未被点亮>`

`<点亮FRUPLight中与请求楼层相对的灯，同时将请求信息写入其中，return true>with<request.type == FRUP，对应的FRUPLight[request.floor-1]未被点亮>`

`<点亮FRDOWNLight中与请求楼层相对的灯，同时将请求信息写入其中，return true>with<request.type == FRDOWN，对应的FRDOWNLight[request.floor-1]未被点亮>`

`<return false>with<request.type对应的三个灯的数组中的request.floor对应的灯已被点亮>`

-   [x] 判断如果request.type == 0(即为DEFINE.ER的值)，且ERLight[request.getFloor() -1]没有亮起，则使其标记是否亮起的标记位置为真，然后写入对应的信息，满足`<点亮ERLight中与请求楼层相对的灯，同时将请求信息写入其中，return true>with<request.type == ER，对应的ERLight[request.floor-1]未被点亮>`
-   [x] 第二三个划分，与第一个划分同理满足

-   [x] 在三个关于request.type的分支判断内，分别判断所对应的灯光数组中对应的某个灯是否亮起，如果已经亮起，都直接return false，满足`<return false>with<request.type对应的三个灯的数组中的request.floor对应的灯已被点亮>`

#### lightOff

```java
/** @REQUIRES:  type == DEFINE.ER || type == DEFINE.FRUP || type == DEFINE.FRDOWN
     *              && 1 <= floor <= 10;
     * @MODIFIES: this.ERLight, this.FRDOWNLight, this.FRUPLight;
     * @EFFECTS: request.type == DEFINE.ER ==> ERLight[request.floor -1].light == false
     *              request.type == DEFINE.FRUP ==> FRUPLight[request.floor -1].light == false
     *              request.type == DEFINE.FRDOWN ==> FRDOWNLight[request.floor -1].light == false
     */
    public void lightOff(int type, int floor)
    {
        if (type == ER)
            ERLight[floor-1].light = false;
        else if (type == FRUP)
            FRUPLight[floor-1].light = false;
        else
            FRDOWNLight[floor-1].light = false;
    }
```

根据以上规格获得以下划分：

`<ERLight[request.floor -1].light == false>with<request.type == ER>`

`<FRUPLight[request.floor -1].light == false>with<request.type == FRUP>`

`<FRDOWNLight[request.floor -1].light == false>with<request.type == FRDOWN>`

根据代码中的分支判断和操作，三个划分显然成立

------

## RequestQueue

### 1. 抽象对象有效实现论证

```java
public class RequestsQueue
{
    /** @OVERVIEW: 用于存储产生的请求，调度器通过从该类中取出得到请求并开始进行调度
     * @Abstract_Function: AF(rq) == (requestLinkedList) where requestLinkedList == rq.requestLinkedList
     * @INVARIANT: requestLinkedList != null && (0 <= i < requestLinkedList.size-1 ==> requestLinkedList.get(i).index < requestLinkedList.get(i+1).index)
     */
```

RequestQueue仅用于记录每一个有效的输入的请求所生成的Request，提供了几个以供放入和取出的方法。类中包含了一个用于存储所有请求的LinkedList，抽象函数中将它映射到了对应的数据结构。 

### 2. 对象有效性论证

**a) 针对构造方法，论证初始态对象的repOK为真。**

使用默认的构造方法为LinkedList初始化，执行完成后LinkedList为空，repOK()显然成立 

**b)逐个论证每个对象状态更改方法的执行都不会导致repOK的返回值为false。**

```java
    /** @REQUIRES:  0 <= index < requestLinkedList.size
     * @EFFECTS: \result == requestLinkedList.get(index)
     */
    public Request get(int index)
    {
        return requestLinkedList.get(index);
    }
```

向LinkedList中添加请求，是唯一的有可能使repOK()为假的方法，但是由于前置条件限制只能将比当前队尾Request序号更大的添加进去，因此执行时不会导致repOK的返回值为false。

**c)该类的几个方法的执行皆不改变对象状态，因此这些方法执行前和执行后的repOK都为true。**

**d)综上，对该类任意对象的任意调用都不会改变其repOK为true的特性。因此该类任意对象始终保持对象有效性。**

### 3. 方法实现正确性论证

#### repOK()

```java
		/**
     * @EFFECTS: \result == I_CLASS(\this)
     */
    public boolean repOK()
    {
        if (requestLinkedList == null)
            return false;
        for (int i = 0; i < requestLinkedList.size()-1; i++)
        {
            if (requestLinkedList.get(i).getIndex() >= requestLinkedList.get(i+1).getIndex())
                return false;
        }
        return true;
    }
```

根据以上规格获得以下划分：

`<if this is legal, return true>with<nothing>`
`<if this is not legal, return false>with<nothing>`

-   [x] 检查对象有效性时被调用，调用时检查各属性满足要求，因此实现正确功能

#### getEarliestUnhandled()

```java
/** @EFFECTS: \result == requestLinkedList.isEmpty()
 */
public Request getEarliestUnhandled()
{
    for (int i = 0; i < size(); i++)
    {
        if (!requestLinkedList.get(i).isHandled())
            return requestLinkedList.get(i);
    }
    return new Request(999, 0, 1, 0);
}
```

根据以上规格获得以下划分：

`<return还没有处理的请求中序号最小的一条请求>with<请求队列中还有没有处理的请求>`
`<return一条序号为999的请求>with<所有请求都已被处理>`

-   [x] 代码行数较短，功能较为简单，从代码中可以看出以上两条划分均成立

------

## RequestReader

### 1. 抽象对象有效实现论证

```java
public class RequestReader
{
    /** @OVERVIEW: 读入并处理请求;
     * @Abstract_Function: AF(rr) == (index, readCount, previousTime) where index == rr.index, readCount == rr.readCount, previousTime == rr.previousTime;
     * @INVARIANT: index >= -1, readCount >= -1, previousTime >= 0;
     */
```

RequestReader用于从控制台读入输入的请求，如果读入的是不符合规则的请求，报错提示；如果读入的是符合要求的请求，生成相应的Request并传入RequestQueue中，直到读入结束符或者达到上限。类中存储了当前已经生成的指令的个数，已经读入的请求的数量和上一条生成的请求的时间，抽象函数中将它们映射到了对应的数据结构。 

### 2. 对象有效性论证

**a) 针对构造方法，论证初始态对象的repOK为真。**

使用默认的构造方法为各属性初始化，repOK()显然成立 

```java
private int index = -1;
private int readCount = -1;
private long previousTime = 0;
```



**b)逐个论证每个对象状态更改方法的执行都不会导致repOK的返回值为false。**

```java
 /** @REQUIRES:  System.in;
     * @MODIFIES: this.index, this.readCount, this.previousTime;
     * @EFFECTS: 对于输入的某行指令instr，如果符合要求 ==> 生成相应的Request并添加进RequestQueue
     *                                    不符合要求 ==> 打印输出提示
     */
	public void readin()
```

假设开始时repOK为真

只要输入一行字符串，如果不是“RUN”，则readCount+=1，如果加一后readCount>100，停止获取输入，关闭输入流并退出

如果输入的是符合格式要求和其它要求的请求，index+=1，否则index不被改变。

如果满足其它所有要求，输入的请求的时间也比当前的previousTime不小，则更新previousTime，否则保持不变，因此在每次更新时，其值始终保持不减。

因此，在该函数执行完成后，repOK()的值将不会改变

**c)该类的几个方法的执行皆不改变对象状态，因此这些方法执行前和执行后的repOK都为true。**

**d)综上，对该类任意对象的任意调用都不会改变其repOK为true的特性。因此该类任意对象始终保持对象有效性。**

### 3. 方法实现正确性论证

#### repOK()

```java
    /**@EFFECTS: \result == I_CLASS(\this);
     */
    public boolean repOK()
    {
        if (index >= -1 && readCount >= -1 && previousTime >= 0)
            return true;
        return false;
    }
```

根据以上规格获得以下划分：

`<if this is legal, return true>with<nothing>`
`<if this is not legal, return false>with<nothing>`

-   [x] 检查对象有效性时被调用，调用时检查各属性满足要求，因此实现正确功能

#### readin()

```java
    /** @REQUIRES:  System.in;
     * @MODIFIES: this.index, this.readCount, this.previousTime;
     * @EFFECTS: 对于输入的某行指令instr，如果符合要求 ==> 生成相应的Request并添加进RequestQueue
     *                                    不符合要求 ==> 打印输出提示
     
     */
	public void readin()
	{
		Scanner scan = new Scanner(System.in);
		String str;
		while(scan.hasNextLine())
		{
			str = scan.nextLine().replace(" ","");
			if(str.equals("RUN"))
				break;
            readCount += 1;
            if (readCount > 100)
                break;

            // grammarCheck
            String REGEX= "(\\(FR,\\+?\\d{1,2},(UP|DOWN),\\+?\\d{1,10}\\))|(\\(ER,\\+?\\d{1,2},\\+?\\d{1,10}\\))";
            Pattern P = Pattern.compile(REGEX);
            Matcher M = P.matcher(str);
            if (!M.matches())
            {
                print(str, "不符合语法规则");
                continue;
            }
            // valueCheck
            String[] s = str.split("[(,)]");
            int floor = Integer.parseInt(s[2]);
            if (floor > 10 || floor < 1)
            {
                print(str, "请求的楼层不合法");
                continue;
            }
            long time;
            int type;
            if(s[1].equals("ER"))
            {
                time = Long.parseLong(s[3]);
                type = 0;
            }
            else
            {
                time = Long.parseLong(s[4]);
                if(s[3].equals("UP"))
                {
                    type = 1;
                    if (floor == 10)
                    {
                        print(str, "尝试在10楼按下向上键");
                        continue;
                    }
                }
                else
                {
                    type = 2;
                    if (floor == 1)
                    {
                        print(str, "尝试在1楼按下向下键");
                        continue;
                    }
                }
            }
            if (time < 0 || time > 2*(long)Integer.MAX_VALUE+1)
            {
                print(str, "时间超出范围");
                continue;
            }
            if (index < 0)
            {
                if (time != 0 || floor != 1 || type != 1)
                {
                    print(str, "第一条请求不是(FR,1,UP,0)");
                    continue;
                }
            }
            if (time < previousTime)
            {
                print(str, "没有按时间不减的顺序输入");
                continue;
            }
            else
                previousTime = time;

            index++;
            Main.requestsQueue.push(new Request(index, type, floor, time));

		}
		scan.close();
	}
```

根据以上规格获得以下划分：

`<将输入的一行字符串str生成对应的Request>with<str符合指令的格式和其它要求>`

`<调用print输出错误提示>with<从控制台输入的一行字符串str不符合要求>`

`<终止输入>with<输入一行"RUN"或者达到输入上限>`

-   [x] 每读取一行字符串，都与"RUN"进行了比较并比较当前输入行数是否大于100，如果满足前两条中的任意一条，则直接break跳出，停止获取输入，满足`<终止输入>with<输入一行"RUN"或者达到输入上限>`

-   [x] 对于输入的一行字符串，如果去除空格后不是"RUN"，那么先将其与正则表达式进行匹配，检验格式，格式相符继续进行，否则直接continue舍弃该条指令

    符合格式要求的指令在后面依次进行时间、类型、顺序等要求的判断，只要有不满足要求的，则continue，舍弃，只有全部满足要求的才会最后执行`Main.requestsQueue.push(new Request(index, type, floor, time))`。

    综上，`<将输入的一行字符串str生成对应的Request>with<str符合指令的格式和其它要求>`和`<调用print输出错误提示>with<从控制台输入的一行字符串str不符合要求>`这两条成立

#### print()

单纯的按照格式将输入的字符串打印，可理解为get/set方法，无需论证

------

## Scheduler

### 1. 抽象对象有效实现论证 

```java
public class Scheduler implements DEFINE
{
    /** @OVERVIEW: 控制单部电梯的运行和每条合法指令的执行结果输出
     * @Abstract_Function: AF(s) == (timer, floor, mainRequest, direction, handledCount)
     *                      where timer == s.timer, currentFloor == s.floor, mainRequest == s.mainRequest, direction == s.direction, nextHandleIndex == s.handledCount
     * @INVARIANT: timer >= 0
     *             && 1 <= currentFloor <= 10
     *             && mainRequest != null
     *             && direction == UP || direction == DOWN || direction == STILL
     *             && nextHandleIndex >= 0;
     */
```

Scheduler按照其内部每次循环增加的时间，按照时间从RequestQueue中取出相应的指令并进行处理，在处理的过程中点亮指令所对应的灯，如果尝试点亮指令的灯时发现已经亮起，说明是同质指令，输出提示并舍弃该指令。成功处理的指令在规定的关门前或关门后输出执行结果到控制台。

类中存储了当前电梯系统的时间、当前所处的楼层、当前正在被执行的主请求、运行方向、已经被执行过的请求序号等，抽象函数中将它们映射到了对应的数据结构。

### 2. 对象有效性论证

**a) 针对构造方法，论证初始态对象的repOK为真。**

使用默认的构造方法为各属性初始化，repOK()显然成立 

**b)逐个论证每个对象状态更改方法的执行都不会导致repOK的返回值为false。**

```java
/**@MODIFIES: this.currentFloor, this.timer;
 * @EFFECTS: direction == UP ==> currentFloor==\old(currentFloor)+1. timer==\old(timer)+0.5
 *           direction == DOWN ==> currentFloor==\old(currentFloor)-1. timer==\old(timer)+0.5
 *           direction == STILL ==> None
 */
private void move()
```

假设开始时repOK为真

根据运动的方向对楼层进行加/减/不改变，对时间+0.5/不改变，只改变了currentFloor和timer：

对于timer而言，始终是+0.5或者不处理的，因此保持不减，timer大于等于初始值0始终成立

对于currentFloor，1 <= currentFloor <= 10的有效性依赖于调用的其他方法的正确性和RequstQueue内的各个Request正确性，当其他类和方法的有效性都被保证时，currentFloor的有效性将得以保证

因此，在该函数执行完成后，repOK()的值将不会改变

```java
/**@MODIFIES: this.direction, this.mainRequest, this.timer;
 * @EFFECTS: 如果在刚结束的运动方向上有需要捎带的ER指令 ==> 最远的ER指令为新的主指令
 *              没有需要捎带的ER指令 ==> 最早发出的、未执行的指令为新的主指令
 *              如果新的主指令发出时间晚于timer ==> timer == mainRequest.getTime()
 *              根据新的主指令和当前楼层的比较结果判断运动方向
 */
private void getNewMainRequest()
```

假设开始时repOK为真

1.  首先检查有没有需要被捎带的ER请求：如果刚刚结束的运动方向是向上，那么扫描当前楼层到10楼之间（不包括当前楼层包括10楼）的ER请求将其当做新的主指令；如果刚刚结束的运动方向是向下，那么扫描当前楼层到1楼之间（不包括当前楼层包括1楼）的ER请求将其当做新的主指令

    如果没有需要被捎带的ER指令，则新的主指令是未被执行的最早的指令；如果所有指令都已经被执行，那么新的主指令为一条编号为999的无效指令，然后识别出来并使得程序结束运行

    这里只改变了mainRequest，而由前面所述，mainRequest一定是确定的用户指令或作为标记的特殊指令，mainRequest!=null一定成立，repOK也一定为真

2.  然后将当前的电梯时间与新的主请求时间比较，如果新的主请求时间大于当前时间，说明电梯存在空等，直接将电梯时间转到请求发出时间以跳过空等时间；否则时间保持不变

    这一步只改变了timer的值，由前面的叙述可知，timer一定保持不减，所以一定不小于其初始值0，repOK为真依旧成立

3.  最后根据新的主请求的楼层和当前楼层的大小关系决定电梯的运动方向

    大小关系只有大于等于小于三种，分别对应电梯的三种运动方向，所以电梯的运动方向必为UP DOWN STILL三种，repOK保持成立

因此，在该函数执行完成后，repOK()的值将不会改变

```java
/**@MODIFIES: this.nextHandleIndex;
 * @EFFECTS: nextHandleIndex >= 100 || nextHandleIndex >= Main.requestsQueue.size() ==> None
 *          Main.requestsQueue.get(nextHandleIndex).getTime() > timer ==> None
 *          点亮所有在当前主请求之前的请求对应的灯光，如果某请求的灯未被点亮 ==> 点亮
 *                                             如果已被点亮 ==> 同质请求，输出提示
 */
private void lightUp()
```

假设开始时repOK为真

该方法循环检测所有发出时间小于等于当前电梯时间的请求，然后对其进行处理，如果发出时间大于当前时间或者已经处理完所有请求，返回停止处理

1.  进入循环后首先检测上述的循环结束条件，这一步不会改变任何属性

2.  循环到某条需要被处理的指令时，尝试点亮灯光，如果之前没有被点亮则成功点亮不做额外处理，如果已经被点亮则被调用的函数返回false后本函数进行同质请求的打印输出并将该请求设置为已处理

    这一部分没有对类内的属性进行修改，不会影响Scheduler类的repOK，对其他类的影响依赖于所用方法的有效性

3.  每处理一条请求，nextHandleIndex+1，用于指示已经被处理过的请求的数量

    因此nextHandleIndex递增，始终大于等于初始值0恒成立，repOK恒为真

因此，在该函数执行完成后，repOK()的值将不会改变

```java
/**@MODIFIES: this.timer;
 * @EFFECTS: 获取当前楼层的三种灯：ER, FRUP, FRDOWN的状态
 *           如果是主指令或者可以被捎带的指令 ==> 请求处理，熄灭被处理请求的灯光然后点亮开门过程中接收到的请求的灯
 *           如果没有需要处理的请求 ==> None
 */
private void handleLight()
```

假设开始时repOK为真

1.  首先根据currentFloor，取出currentFloor对应的ERLight, FRUPLight, FRDOWNLight，然后按照时间的先后顺序进行比较，判断本次电梯停靠可以处理的请求是否存在、如果存在哪条可以被处理

    这一部分内容对涉及到的所有类都是只进行了对应请求的读取，而没有修改，因此对repOK不会产生影响

2.  如果存在需要处理的请求，timer增加开门时间1s，调用lightUp()处理这一秒的请求的亮灯情况，然后分别调用其他类的方法将对应请求设为已处理 并灭灯

    如果执行到这一步，仅对timer进行增加，操作后repOK显然也成立

因此，在该函数执行完成后，repOK()的值将不会改变

**c)该类的几个方法的执行皆不改变对象状态，因此这些方法执行前和执行后的repOK都为true。**

```java
/**@MODIFIES: this;
 * @EFFECTS: \result.equals(按照ALS进行电梯的调度，按照时间进行请求的处理和电梯运行判断);
 */
public void schedule()
```

自身没有改变任何对象状态，进行的所有工作只是根据情况进行其他方法的调用，依赖于其他各个方法的有效性，自身有效性一定得以保证

*另外的三个方法：repOK和两个打印方法，均仅读取对应对象状态而不会修改对象状态*

**d)综上，对该类任意对象的任意调用都不会改变其repOK为true的特性。因此该类任意对象始终保持对象有效性。**

### 3. 方法实现正确性论证

#### repOK()

```java
    /**
     * @EFFECTS: \result == I_CLASS(\this)
     */
    public boolean repOK()
    {
        if (timer > 0 && currentFloor >= 1 && currentFloor <= 10 && mainRequest != null && (direction == UP || direction == DOWN || direction == STILL) && nextHandleIndex > 0)
            return true;
        return false;
    }
```

根据以上规格获得以下划分：

`<if this is legal, return true>with<nothing>`
`<if this is not legal, return false>with<nothing>`

-   [x] 检查对象有效性时被调用，调用时检查各属性满足要求，因此实现正确功能

#### schedule()

```java
/**@MODIFIES: this;
     * @EFFECTS: \result.equals(按照ALS进行电梯的调度，按照时间进行请求的处理和电梯运行判断);
     */
    public void schedule()
    {
        while (!Main.requestsQueue.isEmpty())
        {
//            System.out.printf("time:%f floor:%d\n", timer, currentFloor);
            if (mainRequest.getFloor() == currentFloor)
                getNewMainRequest();
//            System.out.printf("mainRequest:%d\n", mainRequest.index);
            lightUp();
            move();
            handleLight();
        }
    }
```

功能划分及论证如下：

**`<返回结束运行>with<队列内的所有请求已被处理完全>`**

-   [x] 每次循环判断Main.requestsQueue.isEmpty()，如果为真则说明没有需要处理的请求，结束运行

**`<顺次处理各条请求，处理前需要先选择新的主请求>with<当前主请求已被处理完毕而且还有未处理的请求>`**

-   [x] 如果`mainRequest.getFloor() == currentFloor1`则说明已经到达主请求所请求的楼层且必然已经处理完毕，调用`getNewMainRequest()`获取新的主请求，之后的处理步骤与下一条划分相同

**`<向下处理请求>with<当前的主请求还未被处理>`**

-   [x] 调用`lightUp()`先点亮过去一段时间的请求，然后调用`move()`根据电梯的运动方向改变时间和运动状态，然后调用`handleLight()`进行所到达楼层的请求的处理

#### move()

```java
/**@MODIFIES: this.currentFloor, this.timer;
 * @EFFECTS: direction == UP ==> currentFloor==\old(currentFloor)+1. timer==\old(timer)+0.5
 *           direction == DOWN ==> currentFloor==\old(currentFloor)-1. timer==\old(timer)+0.5
 *           direction == STILL ==> None
 */
private void move()
{
    if (direction == UP)
    {
        currentFloor += 1;
        timer += 0.5;
    }
    else if (direction == DOWN)
    {
        currentFloor -= 1;
        timer += 0.5;
    } else
        return;
}
```

划分如下：

**`<使电梯上升一个楼层>with<direction==UP>`**

-   [x] 电梯运动方向为向上，则将currentFloor加一代表上升一个楼层，然后timer+0.5代表上升一层用时0.5s

**`<使电梯下降一个楼层>with<direction==down>`**

-   [x] 电梯运动方向为向上，则将currentFloor减一代表下降一个楼层，然后timer+0.5代表下降一层用时0.5s

**`<do nothing>with<direction==STILL>`**

-   [x] 其他情况（电梯静止）直接return不做任何动作

#### getNewMainRequest()

```java
    /**@MODIFIES: this.direction, this.mainRequest, this.timer;
     * @EFFECTS: 如果在刚结束的运动方向上有需要捎带的ER指令 ==> 最远的ER指令为新的主指令
     *              没有需要捎带的ER指令 ==> 最早发出的、未执行的指令为新的主指令
     *              如果新的主指令发出时间晚于timer ==> timer == mainRequest.getTime()
     *              根据新的主指令和当前楼层的比较结果判断运动方向
     */
    private void getNewMainRequest()
    {
        boolean isSet = false;
        if (direction == UP)
        {
            for (int i = 10; i > currentFloor; i--)
            {
                if (Main.lights.getLight(ER, i).light)
                {
                    mainRequest = Main.requestsQueue.get(Main.lights.getLight(ER, i).index);
                    isSet = true;
                    break;
                }
            }
        }else if (direction == DOWN)
        {
            for (int i = 1; i < currentFloor; i++)
            {
                if (Main.lights.getLight(ER, i).light)
                {
                    mainRequest = Main.requestsQueue.get(Main.lights.getLight(ER, i).index);
                    isSet = true;
                    break;
                }
            }
        }

        if (!isSet)
            mainRequest = Main.requestsQueue.getEarliestUnhandled();
        if (mainRequest.getIndex() == 999)
            System.exit(0);
        timer = timer > mainRequest.getTime() ? timer : mainRequest.getTime();
//        System.out.println("index" + mainRequest.index);

        if (mainRequest.getFloor() > currentFloor)
            direction = UP;
        else if (mainRequest.getFloor() < currentFloor)
            direction = DOWN;
        else
            direction = STILL;
    }
```

**`<选择合适的ER指令捎带为主指令>with<当前运动方向上，当前楼层与最远楼层（1或10）之间有ER指令>`**

**`<选择未被处理的最早一条指令作为新的主指令>with<没有可捎带的ER指令且还有未被执行的指令>`**

**`<退出程序>with<所有指令已被处理>`**

-   [x] 首先检查有没有需要被捎带的ER请求：如果刚刚结束的运动方向是向上，那么扫描当前楼层到10楼之间（不包括当前楼层包括10楼）的ER请求将其当做新的主指令；如果刚刚结束的运动方向是向下，那么扫描当前楼层到1楼之间（不包括当前楼层包括1楼）的ER请求将其当做新的主指令

    如果没有需要被捎带的ER指令，则新的主指令是未被执行的最早的指令；如果所有指令都已经被执行，那么新的主指令为一条编号为999的无效指令，然后识别出来并使得程序结束运行

    由此可见，满足这三条划分的功能

**`<timer为新的主指令的时间>with<电梯需空等到指令的发出时间>`**

-   [x] 然后将当前的电梯时间与新的主请求时间比较，如果新的主请求时间大于当前时间，说明电梯存在空等，直接将电梯时间转到请求发出时间以跳过空等时间；否则时间保持不变

**`<选择合适的运动方向>with<当前所处楼层与目标楼层的大小关系>`**

-   [x] 最后根据新的主请求的楼层和当前楼层的大小关系决定电梯的运动方向

#### lightUP()

```java
/**@MODIFIES: this.nextHandleIndex;
 * @EFFECTS: nextHandleIndex >= 100 || nextHandleIndex >= Main.requestsQueue.size() ==> None
 *          Main.requestsQueue.get(nextHandleIndex).getTime() > timer ==> None
 *          点亮所有在当前主请求之前的请求对应的灯光，如果某请求的灯未被点亮 ==> 点亮
 *                                             如果已被点亮 ==> 同质请求，输出提示
 */
private void lightUp()
{
    while(true)
    {
        if (nextHandleIndex >= 100 || nextHandleIndex >= Main.requestsQueue.size())
            return;
        if (Main.requestsQueue.get(nextHandleIndex).getTime() > timer)
            break;
        if (!Main.lights.lightOn(Main.requestsQueue.get(nextHandleIndex)))
        {
            samePrint(nextHandleIndex);
            Main.requestsQueue.setHandled(nextHandleIndex);
        }
        nextHandleIndex++;
    }
}
```

**`<循环检测未被预处理（亮灯）的所有请求直到扫描到的请求超过了当前时间>with<nothing>`**

-   [x] while循环和循环内的两个关于停止条件的判断，检测所有发出时间小于等于当前电梯时间的请求，然后对其进行处理，如果发出时间大于当前时间或者已经处理完所有请求，返回停止处理

**`<将请求对应的灯光点亮>with<当前请求对应的灯未亮起>`**

**`<打印同质请求，并将其标记为处理完成>with<当前请求对应的灯已亮起>`**

-   [x] 循环到某条需要被处理的指令时，调用`Main.lights.lightOn()`尝试点亮灯光，如果之前没有被点亮则成功点亮并放回true，不做额外处理，如果已经被点亮则被调用的函数返回false后本函数进行同质请求的打印输出并将该请求设置为已处理

**`<结束该条处理，nextHandleIndex指向下一条待处理的请求>with<nothing>`**

-   [x] 每处理一条请求，nextHandleIndex+1，用于指示已经被处理过的请求的数量

#### handleLight()

```java
/**@MODIFIES: this.timer;
     * @EFFECTS: 获取当前楼层的三种灯：ER, FRUP, FRDOWN的状态
     *           如果是主指令或者可以被捎带的指令 ==> 请求处理，熄灭被处理请求的灯光然后点亮开门过程中接收到的请求的灯
     *           如果没有需要处理的请求 ==> None
     */
    private void handleLight()
    {
//        System.out.printf("\tcurrentFloor:%d time:%.1f mainRequest:\n\t\ttype:%d floor:%d time:%d\n", currentFloor, timer, mainRequest.type, mainRequest.floor, mainRequest.time);
        int[] lights = new int[3];
        for (int i = 0; i < 3; i++)
            lights[i] = (Main.lights.getLight(i, currentFloor).light ? Main.lights.getLight(i, currentFloor).index : 999);
        Arrays.sort(lights);
        for (int i = 0; i < 3; i++)
        {
            if (lights[i] >= 100)
                break;
            if (Main.requestsQueue.get(lights[i]).getType() == ER)
                handledPrint(lights[i]);
            else if (Main.requestsQueue.get(lights[i]).getType() == FRUP)
            {
                if (direction == UP || mainRequest.getIndex() == lights[i])
                    handledPrint(lights[i]);
                else
                    lights[i] = 999;
            } else
            {
                if (direction == DOWN || mainRequest.getIndex() == lights[i])
                    handledPrint(lights[i]);
                else
                    lights[i] = 999;
            }
        }
        if (lights[0] != 999 || lights[1] != 999 || lights[2] != 999)
        {
            timer += 1;
            lightUp();
            for (int i = 0; i < 3; i++)
            {
                if (lights[i] >= 100)
                    continue;
                Main.requestsQueue.setHandled(lights[i]);
                Main.lights.lightOff(Main.requestsQueue.get(lights[i]).getType(), currentFloor);
            }
        }
    }
```

**`<获取并处理电梯当前所处楼层的请求，电梯在该楼层开关门一次并预处理（亮灯）开关门时间内发出的请求>with<当前楼层的三种灯光中有亮起状态的且亮起的灯光与运动方向匹配，可以被处理>`**

**`<do nothing>with<当前楼层的三种灯光全部熄灭或亮起的灯光与运动方向不匹配>`**

-   [x] 首先将该楼层的三种灯光所对应的指令序号取出并排序，使得能够把他们按照输入顺序进行处理：

    ​	如果灯亮起，取出的编号是对应请求的编号，如果没有亮起，是作为标记的999，999一定会被按从小到大排到最后，因此不会对正常请求的处理顺序造成影响

    然后检测取出的正确指令（非999）是否与运动方向匹配，是否可以被捎带处理或正常处理：

    ​	如果是ER类型的请求，一定会被处理

    ​	如果是FR请求，如果运动方向与请求方向一致，或当前电梯为STILL状态而该请求为主请求

    ​	满足以上两种情况的请求将被处理、打印处理结果，并被标记为处理完成和灭灯

    如果取出的三条指令中存在可以被处理的指令，timer+1，然后调用`lightUp()`预处理（亮灯）开关门时间内发出的请求

#### samePrint()

```java
/** @REQUIRES:  0 <= index < Main.requestQueue.size;
* @MODIFIES: None;
* @EFFECTS: \result.equals(打印同质请求的判断信息);
*/
private void samePrint(int index)
{
    //        System.out.printf("# 同质请求：输入的第%d条合法请求\n", index+1);
    if (Main.requestsQueue.get(index).getType() == 0) //ER
    {
        System.out.printf("#SAME[ER,%d,%d]\n", Main.requestsQueue.get(index).getFloor(), Main.requestsQueue.get(index).getTime());
    } else if (Main.requestsQueue.get(index).getType() == 1) // FR UP
    {
        System.out.printf("#SAME[FR,%d,UP,%d]\n", Main.requestsQueue.get(index).getFloor(), Main.requestsQueue.get(index).getTime());
    } else
    {
        System.out.printf("#SAME[FR,%d,DOWN,%d]\n", Main.requestsQueue.get(index).getFloor(), Main.requestsQueue.get(index).getTime());
    }
}
```

**`<打印编号为index的同质请求信息>with<编号为index的请求是同质请求>`**

本方法只有一步判断指令类型和按照相对应的格式进行输出，满足功能

#### handledPrint()

```java
		/** @REQUIRES:  0 <= index < Main.requestQueue.size;
     *              status == 0 || status == 1 || status == 2;
     * @MODIFIES: None;
     * @EFFECTS: \result.equals(打印电梯运行状态);
     */
    private void handledPrint(int index)
    {
//        System.out.println("\nindex:"+i);
        if (Main.requestsQueue.get(index).getType() == 0) //ER
        {
            System.out.printf("[ER,%d,%d]/", Main.requestsQueue.get(index).getFloor(), Main.requestsQueue.get(index).getTime());
        } else if (Main.requestsQueue.get(index).getType() == 1) // FR UP
        {
            System.out.printf("[FR,%d,UP,%d]/", Main.requestsQueue.get(index).getFloor(), Main.requestsQueue.get(index).getTime());
        } else
        {
            System.out.printf("[FR,%d,DOWN,%d]/", Main.requestsQueue.get(index).getFloor(), Main.requestsQueue.get(index).getTime());
        }

        if (direction == STILL)
            System.out.printf("(%d,STILL,%.1f)\n", currentFloor, timer+1);
        else if (direction == UP)
            System.out.printf("(%d,UP,%.1f)\n", currentFloor, timer);
        else
            System.out.printf("(%d,DOWN,%.1f)\n", currentFloor, timer);
    }
```

**`<打印编号为index的请求信息和执行完毕时电梯运动的方向、楼层、时间>with<编号为index的请求被成功处理完成而且不是同质请求>`**

判断指令类型和按照相对应的格式进行输出指令的信息，然后输出电梯的运行信息，满足功能