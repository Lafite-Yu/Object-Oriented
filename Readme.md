# 面向对象第13次作业 Readme

------

## 第3次作业的Readme

本次作业花了很多时间，但是由于时间紧任务重作业指导书不明确等原因，难免会有考虑不周之处和没有来得及进行充分测试留下的bug，请多包涵。另外，如果你在测试中发现一些会导致无效作业的问题的话：.._:(?_`」 ∠):_ ...跪下求饶

## 电梯调度策略

电梯的调度策略与作业指导书相同，下面对同质请求的情况进行明确：

请求类型共分为三类：ER，FR-UP，FR-DOWN

某条请求A的同质请求指的是在发出请求的时间在请求A发出后且在A执行完毕之间、且请求类型和目标楼层与请求A相同的请求

## 输入要求

### 合法请求的定义

合法请求需要符合以下要求，如果输入了不合法的请求，程序报错，该请求将被抛弃

报错格式：

```
INVALID[去除所有空格的输入内容]
```

中括号内的内容为去除了所有空格的原输入内容，先导零和符号等不作处理

#### 1. 语法要求

语法合法的请求包括以下三种：

(FR,(FLOOR),UP,(TIME))
(FR,(FLOOR),DOWN,(TIME))
(ER,(FLOOR),(TIME))

输入中的半角空格将被忽略，全角空格和TAB等将不被忽略而作为非法输入

其中，FLOOR的格式为：一个可选的正号+一个可以包括前导零但是包括前导零的总数字位数为1~2位的数字，FLOOR的范围为1~10之间的整数

TIME的格式：一个可选的正号+一个可以包括前导零但是包括前导零的总数字位数为1~10位的数字，TIME的范围为0~2^32-1，且TIME必须为整数不支持小数

#### 2. 指令顺序和含义的要求

有效请求序列必须是从0时刻开始的、时间不减的一系列请求，无效的请求将被抛弃

有效请求队列中的第一条必须为`(FR,1,UP,0)`

例：输入的指令序列A中每一条指令的TIME所对应的请求发出时间分别为：

```
A[1] 5
A[2] 7
A[3] 0
A[4] 1
......
```

则A[3]之前的指令序列，即使符合语法要求，也将被抛弃

此外，0层的FR DOWN请求和10层的FR UP请求不合法，

另外，本程序规定：只能输入100条请求，包括有效和无效请求在内，如果已经读入了100条指令，即使没有"RUN",也将强制开始执行。

如果已经读到"RUN"，则"RUN"输入的内容将被抛弃，如果"RUN"前没有有效指令，则电梯无动作，即无内容输出。

如果输入指令不到100行且没有输入RUN，本地测试会一直等待下一行输入，而在线测试到达文件尾结束。当在线测试到达文件尾时，即使没有RUN，也将强制开始执行

## 输出

输入的请求分为三类：

1.不合法的请求，参见上一节

2.合法的同质请求，参见第一节

3.合法的、且与其之前指令不同质的指令

这一部分的指令，包括普通请求和捎带请求

根据指令类型的不同，输出分别如下：

1.不合法的请求：

报INVALID错误，详见上一节

2.合法的同质请求，参见第一节

只输出SAME和同质指令，格式如下：

```
如果为FR指令：
#SAME[FR,(FLOOR),UP,(TIME)]
#SAME[FR,(FLOOR),UP,(TIME)]
如果为ER指令
#SAME[ER,(FLOOR),(TIME)]
```
FR为请求的楼层，TIME为请求的时间，数值上与输入的指令相等同，但输出的仅为纯数字，不包括符号和前导零

报SAME错误时，内部的指令格式参见作业指导书

3.合法的、且与其之前指令不同质的指令

输出电梯的运行状态，输出格式详见作业指导书

其它未详尽部分，皆继承作业指导书的要求或如果readme没有提及，但是代码实现中有所体现并进行了处理的情况，以代码实际运行情况为准

程序中存在的问题请多包涵，不要互相伤害，虽然已经进行过一些测试，但是由于时间等关系，没有进行完整的测试，如果可能出现无效问题的话……再次跪求

/*非常感谢你耐心读到这里！谢谢你！大家共同进步，祝OO顺利(⊙ω⊙)！*/

## 第13次作业增加的要求

### 关于重构和第三次作业的bug

代码经过了少许重构，去除了第三次作业中的非功能性要求，根据issue，第三次作业的非功能性要求例如继承和接口不再作为要求。

代码中的bug没有修复，针对第三次作业的bug构造了测试样例，具体说明如下：

> 公测无bug，互测中的三个bug如下：
> 1.输入的第一条请求只要是从一楼、零时刻发出的请求都被认为为有效，即使不是(FR,1,UP,0)。
> 输入处理，不属于功能性bug，不需要构造测试样例重现
> 2.如果没有输入有效指令直接开始运行，由于Scheduler->schedule方法的逻辑问题，虽然没有从请求队列中取出指令，但是由于没有正确判断并退出，
> 得到了一条初始值都为零的指令信息info，即[ER,0,0]，并开始执行
> 此bug在TestCaseError0复现
> 3.由于由于Scheduler->schedule方法的逻辑问题，使得在某些特殊情况下，多重捎带处理时会丢弃开关门的1s而没有计算在内
> 此bug在TestCaseError1和TestCaseError2复现。

### 测试用例和测试结果的概述：

#### 关于`repOK`

根据助教要求，所有类都要写repOK但是只有提到的三个类需要些JSF

基于以下原因，repOK的覆盖率不作处理：

- 针对构造方法，初始状态repOK为真 
- 每个对象状态更改方法的执行都不会导致repOK的返回值为false 
- 对于一个方法，开始执行时假设repOK返回值为true 
- 对于一个方法，方法做的修改不会修改repOK 
- 其他的方法不改变对象状态 

以上是公测bug树分支，由于任何情况下repOK都应为真，所以判断为假的分支以及`return false`的语句必定不会执行，则代码覆盖率和分支覆盖率都不会达到要求，对repOK的覆盖率进行要求简直是无理取闹，而且如果测试到了repOK的`return false`情况，则应该为bug。

补充：

不合理的要求就应该利用规则漏洞来解决，对于构造方法不需要传入其他类而所有属性均为private、所有方法本身和前置条件均保证repOK成立的，直接`return true`，bug树和覆盖率就都没问题了，美滋滋

##### 关于`Main`类（各种初始化和输入）

内部除去`repOK`以外只有`main`方法，按照指导书要求，`main`不进行测试

#### `Request`类

##### `judger`

测试用例数目：11

分支覆盖率：92%

语句覆盖率：100%

bug数：均无

其他方法会被该方法调用，不再单独测试

#### `Elevator`类

##### `getLight`

get方法，不需编写测试代码

##### `lightOn`&`lightOff`

set方法，不需编写测试代码

#### `RequestsQueue`类

##### `setSame`

测试用例数目：1

分支覆盖率：100%

语句覆盖率：100%

bug数：均无

##### 除此方法外，此类中的其他非构造方法均为无分支处理的简单set或get方法

#### `Scheduler`类 

##### `schedule`

除列出的方法以外，其他方法均会被该方法所调用且均为`private`或`protected`，因此视为同样被针对该方法构造的测试样例所检测而不再单独测试。被忽略的方法的语句覆盖率均为100%，分支覆盖率均高于85%，详情可见提交的覆盖率报告。

测试用例数目：16

分支覆盖率：92%

语句覆盖率：99%（覆盖不动了，不管了，你可以直接按照指导书报一个这个方法的语句覆盖率的incomplete）

所复现的bug数：2

新发现的bug数：无

根据助教要求，控制台输出只需要覆盖到即可而不需要使用`assert`进行判断。针对两个bug的三个测试样例的期望输出在代码注释中注明。